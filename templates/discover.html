{% extends "base.html" %}

{% block title %}Discover Videos - Podcast Summarizer{% endblock %}

{% block content %}
<div class="container">
    <div class="hero-section">
        <h2>üîç Discover New Videos</h2>
        <p>Find the latest videos from your trusted finance channels</p>
    </div>

    <div class="discovery-controls">
        <button 
            id="discoverBtn"
            class="btn btn-primary" 
            onclick="discoverVideos()"
        >
            üöÄ Discover New Videos (Last {{ discovery_days_back }} Days)
        </button>

        <button 
            id="analyzeAllBtn"
            class="btn btn-primary"
            onclick="analyzeAllVideos()"
        >
            üîç Analyze All New Episodes
        </button>

        <button 
            class="btn btn-secondary" 
            hx-get="/api/recent" 
            hx-target="#video-grid"
        >
            üìö Show Recent
        </button>

        <!-- Multi-Select Controls -->
        <div class="multi-select-controls" style="margin-top: 1rem; display: none;" id="multiSelectControls">
            <div class="select-all-container">
                <label>
                    <input type="checkbox" id="selectAll" onchange="toggleSelectAll()">
                    <span>Select All</span>
                </label>
                <span id="selectedCount" class="selected-count">0 selected</span>
            </div>
            
            <div class="channel-filter-container">
                <label for="channelFilter">Filter by Channel:</label>
                <select id="channelFilter" onchange="filterByChannel()">
                    <option value="all">All Channels</option>
                </select>
            </div>
            
            <button 
                id="analyzeSelectedBtn"
                class="btn btn-primary"
                onclick="analyzeSelectedVideos()"
                disabled
            >
                üîç Analyze Selected (0)
            </button>
        </div>

        <div id="discovery-loading" class="loading" style="display: none;">
            <div class="spinner"></div>
            <p id="loading-message">Discovering videos...</p>
        </div>
        
        <div id="batch-progress" class="batch-progress" style="display: none;">
            <div class="progress-bar">
                <div id="progress-fill" class="progress-fill" style="width: 0%"></div>
            </div>
            <p id="progress-text">Analyzing videos...</p>
        </div>
    </div>

    <div id="video-grid" class="video-grid">
        <!-- Videos will be loaded here -->
        <div class="empty-state">
            <p>üëÜ Click "Discover New Videos" to find the latest content from trusted channels</p>
        </div>
    </div>
</div>

<script>
// Get discovery_days_back from template
const DISCOVERY_DAYS_BACK = {{ discovery_days_back }};

// Discover videos from last N days
async function discoverVideos(days = DISCOVERY_DAYS_BACK) {
    const loading = document.getElementById('discovery-loading');
    const loadingMessage = document.getElementById('loading-message');
    
    loading.style.display = 'block';
    loadingMessage.textContent = `Discovering videos from last ${days} days...`;
    
    try {
        const response = await fetch(`/api/discover?days_back=${days}`);
        if (response.status === 429) {
            const errorData = await response.json();
            const grid = document.getElementById('video-grid');
            grid.innerHTML = `
                <div class="quota-error-state">
                    <h3>‚è≥ YouTube API Quota Exceeded</h3>
                    <p>${errorData.detail}</p>
                    <p>The YouTube API has a daily limit. Please try again in 24 hours.</p>
                </div>
            `;
            return;
        }
        const data = await response.json();
        renderVideoGrid(data.videos);
    } catch (error) {
        console.error('Error discovering videos:', error);
        alert('Failed to discover videos');
    } finally {
        loading.style.display = 'none';
    }
}

// Analyze all new episodes
async function analyzeAllVideos() {
    const batchProgress = document.getElementById('batch-progress');
    const progressText = document.getElementById('progress-text');
    const progressFill = document.getElementById('progress-fill');
    
    if (!confirm(`This will analyze all new videos from the last ${DISCOVERY_DAYS_BACK} days. This may take several minutes. Continue?`)) {
        return;
    }
    
    batchProgress.style.display = 'block';
    progressText.textContent = 'Starting batch analysis...';
    
    try {
        const response = await fetch('/api/batch-analyze', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ days_back: DISCOVERY_DAYS_BACK })
        });
        
        const result = await response.json();
        
        if (result.total_videos > 0) {
            const percentage = ((result.analyzed / result.total_videos) * 100).toFixed(0);
            progressFill.style.width = `${percentage}%`;
            progressText.textContent = `Analyzed ${result.analyzed} of ${result.total_videos} videos (${result.failed} failed)`;
            
            // Refresh the grid to show updated status
            await discoverVideos(DISCOVERY_DAYS_BACK);
            
            alert(`Batch analysis complete!\n\nAnalyzed: ${result.analyzed}\nFailed: ${result.failed}\nTotal: ${result.total_videos}`);
        } else {
            progressText.textContent = 'No new videos found to analyze';
        }
        
    } catch (error) {
        console.error('Error in batch analysis:', error);
        alert('Batch analysis failed');
    } finally {
        setTimeout(() => {
            batchProgress.style.display = 'none';
        }, 3000);
    }
}

// Custom HTMX response handler for video discovery
document.body.addEventListener('htmx:afterRequest', function(event) {
    if (event.detail.xhr.responseURL.includes('/api/recent')) {
        try {
            const data = JSON.parse(event.detail.xhr.responseText);
            renderVideoGrid(data.videos);
        } catch (e) {
            console.error('Error parsing response:', e);
        }
    }
});

// Store all videos globally for filtering
let allVideos = [];

function renderVideoGrid(videos) {
    const grid = document.getElementById('video-grid');
    if (!videos || videos.length === 0) {
        grid.innerHTML = '<div class="empty-state"><p>No videos found</p></div>';
        return;
    }

    // Store videos for filtering
    allVideos = videos;
    
    // Populate channel filter
    populateChannelFilter(videos);
    
    // Render videos
    renderFilteredVideos(videos);
}

function populateChannelFilter(videos) {
    const channelFilter = document.getElementById('channelFilter');
    if (!channelFilter) return;
    
    // Get unique channels
    const channels = [...new Set(videos.map(video => video.channel_name))].sort();
    
    // Clear existing options except "All Channels"
    channelFilter.innerHTML = '<option value="all">All Channels</option>';
    
    // Add channel options
    channels.forEach(channel => {
        const option = document.createElement('option');
        option.value = channel;
        option.textContent = channel;
        channelFilter.appendChild(option);
    });
}

function renderFilteredVideos(videos) {
    const grid = document.getElementById('video-grid');
    
    const videosHTML = videos.map(video => {
        const analyzedClass = video.analyzed ? 'analyzed' : 'not-analyzed';
        
        // Determine badge based on status
        let analyzedBadge;
        if (video.analyzed) {
            analyzedBadge = '<span class="analyzed-badge">‚úÖ Analyzed</span>';
        } else if (video.in_progress) {
            analyzedBadge = '<span class="in-progress-badge">üîÑ Analyzing...</span>';
        } else {
            analyzedBadge = '<span class="not-analyzed-badge">‚è≥ Not Analyzed</span>';
        }
        
        // Only show checkbox for non-analyzed videos
        const checkboxHtml = !video.analyzed ? `
            <div class="video-select-checkbox">
                <input type="checkbox" class="video-checkbox" 
                       data-video-id="${video.video_id}" 
                       data-video-url="${video.url}"
                       onchange="updateSelectedCount()">
            </div>` : '';
        
        return `
        <div class="video-card ${analyzedClass}" id="video-card-${video.video_id}">
            ${checkboxHtml}
            <div class="video-thumbnail">
                <img src="https://img.youtube.com/vi/${video.video_id}/hqdefault.jpg" alt="${video.title}">
                <div class="video-duration">${formatDuration(video.duration)}</div>
                <div id="badge-${video.video_id}">${analyzedBadge}</div>
            </div>
            <div class="video-info">
                <h3 class="video-title">${video.title}</h3>
                <p class="video-channel">üì∫ ${video.channel_name}</p>
                <p class="video-date">üìÖ ${formatDate(video.published_at)}</p>
                <div class="video-actions">
                    <a href="${video.url}" target="_blank" class="btn btn-sm">
                        ‚ñ∂Ô∏è Watch
                    </a>
                    ${video.analyzed ? 
                        `<a href="/dashboard" class="btn btn-sm btn-secondary">
                            üìä View Analysis
                        </a>` :
                        `<button 
                            id="analyze-btn-${video.video_id}"
                            class="btn btn-sm btn-primary" 
                            onclick="analyzeVideoDirectly('${video.url}', '${video.video_id}')"
                        >
                            üîç Analyze
                        </button>`
                    }
                </div>
            </div>
        </div>
    `}).join('');

    grid.innerHTML = videosHTML;
    
    // Show multi-select controls when videos are loaded
    const multiSelectControls = document.getElementById('multiSelectControls');
    if (multiSelectControls) {
        multiSelectControls.style.display = 'block';
    }
    
    // Reset selection state
    updateSelectedCount();
}

// Channel filter functionality
function filterByChannel() {
    const channelFilter = document.getElementById('channelFilter');
    const selectedChannel = channelFilter.value;
    
    let filteredVideos;
    if (selectedChannel === 'all') {
        filteredVideos = allVideos;
    } else {
        filteredVideos = allVideos.filter(video => video.channel_name === selectedChannel);
    }
    
    renderFilteredVideos(filteredVideos);
}

function formatDuration(seconds) {
    const mins = Math.floor(seconds / 60);
    const secs = seconds % 60;
    return `${mins}:${secs.toString().padStart(2, '0')}`;
}

function formatDate(dateStr) {
    return new Date(dateStr).toLocaleDateString();
}

async function analyzeVideoDirectly(url, videoId) {
    const button = document.getElementById(`analyze-btn-${videoId}`);
    const badge = document.getElementById(`badge-${videoId}`);
    const card = document.getElementById(`video-card-${videoId}`);
    const originalText = button.innerHTML;
    
    // Show processing state
    button.innerHTML = '‚è≥ Analyzing...';
    button.disabled = true;
    badge.innerHTML = '<span class="processing-badge">üîÑ Processing</span>';
    
    try {
        const response = await fetch('/api/analyze', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ video_url: url })
        });
        
        if (response.ok) {
            const data = await response.json();
            
            // Show success state
            button.innerHTML = '‚úÖ Analyzed!';
            badge.innerHTML = '<span class="analyzed-badge">‚úÖ Analyzed</span>';
            card.className = 'video-card analyzed';
            
            // Replace analyze button with view analysis button
            setTimeout(() => {
                button.outerHTML = `<a href="/dashboard" class="btn btn-sm btn-secondary">üìä View Analysis</a>`;
            }, 1500);
            
        } else {
            throw new Error('Analysis failed');
        }
        
    } catch (error) {
        console.error('Error analyzing video:', error);
        
        // Show error state and restore
        button.innerHTML = '‚ùå Failed';
        badge.innerHTML = '<span class="not-analyzed-badge">‚è≥ Not Analyzed</span>';
        
        setTimeout(() => {
            button.innerHTML = originalText;
            button.disabled = false;
        }, 2000);
    }
}

// Multi-select functionality
function updateSelectedCount() {
    const checkboxes = document.querySelectorAll('.video-checkbox');
    const checkedBoxes = document.querySelectorAll('.video-checkbox:checked');
    const count = checkedBoxes.length;
    
    // Update count display
    const countDisplay = document.getElementById('selectedCount');
    if (countDisplay) {
        countDisplay.textContent = `${count} selected`;
    }
    
    // Update analyze selected button
    const analyzeBtn = document.getElementById('analyzeSelectedBtn');
    if (analyzeBtn) {
        analyzeBtn.textContent = `üîç Analyze Selected (${count})`;
        analyzeBtn.disabled = count === 0;
    }
    
    // Update select all checkbox state
    const selectAllCheckbox = document.getElementById('selectAll');
    if (selectAllCheckbox) {
        const availableCount = checkboxes.length; // Only non-analyzed videos have checkboxes
        selectAllCheckbox.checked = count > 0 && count === availableCount;
        selectAllCheckbox.indeterminate = count > 0 && count < availableCount;
    }
}

function toggleSelectAll() {
    const selectAllCheckbox = document.getElementById('selectAll');
    const videoCheckboxes = document.querySelectorAll('.video-checkbox');
    
    videoCheckboxes.forEach(checkbox => {
        checkbox.checked = selectAllCheckbox.checked;
    });
    
    updateSelectedCount();
}

async function analyzeSelectedVideos() {
    const checkedBoxes = document.querySelectorAll('.video-checkbox:checked');
    if (checkedBoxes.length === 0) {
        alert('Please select some videos to analyze');
        return;
    }
    
    const videoUrls = Array.from(checkedBoxes).map(checkbox => 
        checkbox.getAttribute('data-video-url')
    );
    
    const batchProgress = document.getElementById('batch-progress');
    const progressText = document.getElementById('progress-text');
    const progressFill = document.getElementById('progress-fill');
    
    if (!confirm(`This will analyze ${videoUrls.length} selected videos. This may take several minutes. Continue?`)) {
        return;
    }
    
    batchProgress.style.display = 'block';
    progressText.textContent = `Starting analysis of ${videoUrls.length} videos...`;
    progressFill.style.width = '0%';
    
    try {
        // Start the batch analysis (non-blocking)
        const response = await fetch('/api/batch-analyze-selected', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({ video_urls: videoUrls })
        });
        
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        
        const result = await response.json();
        const batchId = result.batch_id;
        
        // Start polling for progress
        let pollCount = 0;
        const maxPolls = 300; // 5 minutes max (300 * 1000ms = 5 min)
        
        const pollProgress = async () => {
            try {
                const progressResponse = await fetch(`/api/batch-progress/${batchId}`);
                if (!progressResponse.ok) {
                    throw new Error('Progress not found');
                }
                
                const progress = await progressResponse.json();
                
                // Update progress bar
                progressFill.style.width = `${progress.percent}%`;
                
                // Update progress text
                if (progress.current_video) {
                    progressText.textContent = `Analyzing "${progress.current_video}" (${progress.completed}/${progress.total})`;
                } else if (progress.status === 'completed') {
                    progressText.textContent = `Analysis complete! ${progress.completed} of ${progress.total} videos (${progress.failed} failed)`;
                } else {
                    progressText.textContent = `Processed ${progress.completed} of ${progress.total} videos (${progress.failed} failed)`;
                }
                
                // Check if completed
                if (progress.status === 'completed' || progress.completed >= progress.total) {
                    // Refresh the grid to show updated status
                    await discoverVideos(DISCOVERY_DAYS_BACK);
                    
                    alert(`Analysis complete!\n\nAnalyzed: ${progress.completed}\nFailed: ${progress.failed}\nTotal: ${progress.total}`);
                    
                    setTimeout(() => {
                        batchProgress.style.display = 'none';
                    }, 3000);
                    return;
                }
                
                // Continue polling if not completed and haven't exceeded max polls
                pollCount++;
                if (pollCount < maxPolls) {
                    setTimeout(pollProgress, 1000); // Poll every 1 second
                } else {
                    progressText.textContent = 'Analysis timed out - check dashboard for results';
                    setTimeout(() => {
                        batchProgress.style.display = 'none';
                    }, 3000);
                }
                
            } catch (pollError) {
                console.error('Error polling progress:', pollError);
                // If polling fails, fall back to final result
                progressText.textContent = `Analysis complete! Check dashboard for results.`;
                setTimeout(() => {
                    batchProgress.style.display = 'none';
                }, 3000);
            }
        };
        
        // Start polling after a brief delay
        setTimeout(pollProgress, 1000);
        
    } catch (error) {
        console.error('Error in selected video analysis:', error);
        alert('Analysis of selected videos failed: ' + error.message);
        batchProgress.style.display = 'none';
    }
}
</script>

<style>
.batch-progress {
    background: white;
    padding: 1rem;
    border-radius: 8px;
    margin-top: 1rem;
}

.progress-bar {
    width: 100%;
    height: 20px;
    background: #e0e0e0;
    border-radius: 10px;
    overflow: hidden;
    margin-bottom: 0.5rem;
}

.progress-fill {
    height: 100%;
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    transition: width 0.3s ease;
}

.analyzed-badge, .not-analyzed-badge, .processing-badge {
    position: absolute;
    top: 8px;
    left: 8px;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: bold;
}

.analyzed-badge {
    background: rgba(76, 175, 80, 0.9);
    color: white;
}

.not-analyzed-badge {
    background: rgba(255, 152, 0, 0.9);
    color: white;
}

.processing-badge {
    background: rgba(33, 150, 243, 0.9);
    color: white;
    animation: pulse 1.5s infinite;
}

.in-progress-badge {
    background: rgba(255, 193, 7, 0.9);
    color: white;
    position: absolute;
    top: 8px;
    left: 8px;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.75rem;
    font-weight: bold;
    animation: pulse 1.5s infinite;
}

@keyframes pulse {
    0% { opacity: 1; }
    50% { opacity: 0.7; }
    100% { opacity: 1; }
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

.video-card.analyzed {
    border: 2px solid #4caf50;
    position: relative;
}

.video-card.analyzed::after {
    content: "‚úÖ ANALYZED";
    position: absolute;
    top: 8px;
    right: 8px;
    background: rgba(76, 175, 80, 0.9);
    color: white;
    padding: 0.25rem 0.5rem;
    border-radius: 4px;
    font-size: 0.7rem;
    font-weight: bold;
    z-index: 5;
}

.video-card.not-analyzed {
    opacity: 0.95;
}

/* Multi-select controls styling */
.multi-select-controls {
    background: white;
    padding: 1rem;
    border-radius: 8px;
    border: 1px solid #ddd;
    display: flex;
    align-items: center;
    gap: 1rem;
    flex-wrap: wrap;
}

.select-all-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.select-all-container label {
    display: flex;
    align-items: center;
    gap: 0.5rem;
    cursor: pointer;
    font-weight: bold;
}

.selected-count {
    color: #666;
    font-size: 0.9rem;
}

.channel-filter-container {
    display: flex;
    align-items: center;
    gap: 0.5rem;
}

.channel-filter-container label {
    font-weight: bold;
    color: #333;
}

.channel-filter-container select {
    padding: 0.5rem;
    border: 1px solid #ddd;
    border-radius: 4px;
    background: white;
    font-size: 0.9rem;
    cursor: pointer;
}

.channel-filter-container select:focus {
    outline: none;
    border-color: #667eea;
    box-shadow: 0 0 0 2px rgba(102, 126, 234, 0.2);
}

.video-select-checkbox {
    position: absolute;
    top: 8px;
    right: 8px;
    z-index: 10;
}

.video-select-checkbox input[type="checkbox"] {
    width: 18px;
    height: 18px;
    cursor: pointer;
}

.video-card {
    position: relative;
}

.quota-error-state {
    text-align: center;
    padding: 3rem;
    background: #fff3cd;
    border: 1px solid #ffeaa7;
    border-radius: 8px;
    margin: 2rem 0;
}

.quota-error-state h3 {
    color: #856404;
    margin-bottom: 1rem;
}

.quota-error-state p {
    color: #856404;
    margin-bottom: 0.5rem;
}
</style>
{% endblock %}